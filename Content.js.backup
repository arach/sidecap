(function () {
  const ROOT_ID = "captions-root";
  const OVERLAY_ID = "captions-overlay";
  const CAPTION_POLL_MS = 500;
  const REPLAY_BACK_SECONDS = 1.6;
  const STATUS_FLASH_MS = 1600;
  const DICTIONARY_API_BASE = "https://freedictionaryapi.com/api/v1/entries";
  const DICTIONARY_CACHE_TTL_MS = 60 * 60 * 1000;
  const CONTROL_SEEK_SECONDS = 5;

  const defaultConfig = {
    align: "left",
    fontSize: 16,
    opacity: 0.88,
    bottomOffset: 12,
    maxWidth: 24,
    dictionaryLang: "en",
    translationLang: "all",
    historyEnabled: true,
    historySize: 8,
  };

  const config = { ...defaultConfig };

  if (document.getElementById(ROOT_ID)) {
    return;
  }

  const state = {
    mode: "same",
    panelOpen: true,
    devToolsCollapsed: false,
    activeTab: "captions",
    renderedCaptionText: "",
    statusOverrideText: "",
    statusOverrideUntil: 0,
    captionContainer: null,
    captionObserver: null,
    activeWord: "",
    lookupRequestId: 0,
    captionHistory: [],
    lastHistoryKey: "",
    historyId: 0,
    historyListEl: null,
    historyEmptyEl: null,
    historyPanelEl: null,
    dockEl: null,
    lastCaptionText: "",
  };

  const dictionaryCache = new Map();

  function createElement(tag, className) {
    const el = document.createElement(tag);
    if (className) {
      el.className = className;
    }
    return el;
  }

  function normalizeWord(rawWord) {
    const trimmed = rawWord.trim();
    if (!trimmed) {
      return "";
    }
    return trimmed.replace(/^[^\p{L}\p{N}]+|[^\p{L}\p{N}]+$/gu, "");
  }

  function getCacheKey(word, language) {
    return `${language}:${word.toLowerCase()}`;
  }

  function getCachedEntry(key) {
    const cached = dictionaryCache.get(key);
    if (!cached) {
      return null;
    }
    if (Date.now() - cached.timestamp > DICTIONARY_CACHE_TTL_MS) {
      dictionaryCache.delete(key);
      return null;
    }
    return cached.data;
  }

  function setCachedEntry(key, data) {
    dictionaryCache.set(key, { data, timestamp: Date.now() });
  }

  async function fetchDictionaryEntry(word, language) {
    const url = `${DICTIONARY_API_BASE}/${language}/${encodeURIComponent(
      word
    )}?translations=true`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Dictionary lookup failed (${response.status}).`);
    }
    return response.json();
  }

  function flattenSenses(senses) {
    const queue = Array.isArray(senses) ? [...senses] : [];
    const flattened = [];
    while (queue.length) {
      const sense = queue.shift();
      if (!sense) {
        continue;
      }
      flattened.push(sense);
      if (Array.isArray(sense.subsenses)) {
        queue.push(...sense.subsenses);
      }
    }
    return flattened;
  }

  function uniqueItems(items) {
    return Array.from(new Set(items.filter(Boolean)));
  }

  function collectPronunciations(entry) {
    return uniqueItems(
      (entry?.pronunciations || [])
        .map((pronunciation) => {
          const text = pronunciation?.text?.trim();
          const type = pronunciation?.type?.trim();
          const tags = (pronunciation?.tags || []).filter(Boolean);
          if (!text && !type) {
            return "";
          }
          let line = "";
          if (type && text) {
            line = `${type}: ${text}`;
          } else {
            line = type || text;
          }
          if (tags.length) {
            line += ` (${tags.join(", ")})`;
          }
          return line.trim();
        })
        .filter(Boolean)
    );
  }

  function collectForms(entry) {
    return uniqueItems(
      (entry?.forms || [])
        .map((form) => {
          const word = form?.word?.trim();
          if (!word) {
            return "";
          }
          const tags = (form?.tags || []).filter(Boolean);
          if (!tags.length) {
            return word;
          }
          return `${word} (${tags.join(", ")})`;
        })
        .filter(Boolean)
    );
  }

  function collectRelatedWords(entry, senses, key) {
    const words = new Set();
    (entry?.[key] || []).forEach((word) => {
      if (word) {
        words.add(word);
      }
    });
    senses.forEach((sense) => {
      (sense?.[key] || []).forEach((word) => {
        if (word) {
          words.add(word);
        }
      });
    });
    return Array.from(words);
  }

  function collectTranslations(entries) {
    const map = new Map();
    entries.forEach((entry) => {
      const senses = flattenSenses(entry?.senses || []);
      senses.forEach((sense) => {
        (sense.translations || []).forEach((translation) => {
          const code = translation.language?.code || "unknown";
          const name = translation.language?.name || code;
          const key = `${code}:${name}`;
          if (!map.has(key)) {
            map.set(key, { code, name, words: new Set() });
          }
          if (translation.word) {
            map.get(key).words.add(translation.word);
          }
        });
      });
    });
    return Array.from(map.values()).map((entry) => ({
      code: entry.code,
      name: entry.name,
      words: Array.from(entry.words),
    }));
  }

  function parseDictionaryData(data, translationLang) {
    const entry = data?.entries?.[0];
    const senses = flattenSenses(entry?.senses || []);
    const definitions = senses
      .map((sense) => sense.definition)
      .filter(Boolean)
      .slice(0, 3);
    const examples = senses
      .flatMap((sense) => sense.examples || [])
      .filter(Boolean)
      .slice(0, 2);
    let translations = collectTranslations(data?.entries || []);
    if (translationLang && translationLang !== "all") {
      const target = translationLang.toLowerCase();
      translations = translations.filter(
        (translation) => translation.code?.toLowerCase() === target
      );
    }
    return {
      languageName: entry?.language?.name || "",
      languageCode: entry?.language?.code || "",
      partOfSpeech: entry?.partOfSpeech || "",
      pronunciations: collectPronunciations(entry),
      forms: collectForms(entry),
      synonyms: collectRelatedWords(entry, senses, "synonyms"),
      antonyms: collectRelatedWords(entry, senses, "antonyms"),
      definitions,
      examples,
      translations,
      translationLang: translationLang || "all",
      sourceUrl: data?.source?.url || "",
    };
  }

  function formatLines(items, formatItem) {
    if (!items.length) {
      return "";
    }
    return items.map((item, index) => formatItem(item, index)).join("\n");
  }

  function getVideo() {
    return document.querySelector("video");
  }

  function formatTimestamp(seconds) {
    if (!Number.isFinite(seconds) || seconds < 0) {
      return "00:00";
    }
    const totalSeconds = Math.floor(seconds);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;
    const paddedMinutes = String(minutes).padStart(2, "0");
    const paddedSeconds = String(secs).padStart(2, "0");
    if (hours > 0) {
      return `${hours}:${paddedMinutes}:${paddedSeconds}`;
    }
    return `${paddedMinutes}:${paddedSeconds}`;
  }

  function normalizeHistoryKey(text) {
    return text.replace(/\s+/g, " ").trim().toLowerCase();
  }

  function formatHistoryText(text) {
    return text.replace(/\s+/g, " ").trim();
  }

  function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }

  function normalizeConfig(nextConfig) {
    return {
      align: nextConfig.align === "center" ? "center" : "left",
      fontSize: clamp(
        Number(nextConfig.fontSize) || defaultConfig.fontSize,
        12,
        26
      ),
      opacity: clamp(
        Number(nextConfig.opacity) || defaultConfig.opacity,
        0.55,
        0.95
      ),
      bottomOffset: clamp(
        Number(nextConfig.bottomOffset) || defaultConfig.bottomOffset,
        6,
        24
      ),
      maxWidth: clamp(
        Number(nextConfig.maxWidth) || defaultConfig.maxWidth,
        18,
        45
      ),
      dictionaryLang:
        typeof nextConfig.dictionaryLang === "string" &&
        nextConfig.dictionaryLang.trim()
          ? nextConfig.dictionaryLang
          : defaultConfig.dictionaryLang,
      translationLang:
        typeof nextConfig.translationLang === "string" &&
        nextConfig.translationLang.trim()
          ? nextConfig.translationLang
          : defaultConfig.translationLang,
      historyEnabled:
        typeof nextConfig.historyEnabled === "boolean"
          ? nextConfig.historyEnabled
          : defaultConfig.historyEnabled,
      historySize: clamp(
        Number(nextConfig.historySize) || defaultConfig.historySize,
        3,
        20
      ),
    };
  }

  function applyConfig(root, overlay) {
    const normalized = normalizeConfig(config);
    Object.assign(config, normalized);
    root.style.setProperty(
      "--captions-overlay-opacity",
      config.opacity.toFixed(2)
    );
    root.style.setProperty(
      "--captions-overlay-opacity-2",
      Math.max(0, config.opacity - 0.1).toFixed(2)
    );
    root.style.setProperty(
      "--captions-sheet-height",
      `${config.maxWidth}vh`
    );
    overlay.style.textAlign = config.align;
    overlay.style.fontSize = `${config.fontSize}px`;
  }

  function getPlayerRect() {
    const player = document.querySelector("#movie_player, .html5-video-player");
    if (!player) {
      return null;
    }
    const rect = player.getBoundingClientRect();
    if (!rect.width || rect.width < 120) {
      return null;
    }
    return rect;
  }

  function updateDockPosition() {
    const dock = state.dockEl;
    if (!dock) {
      return;
    }
    dock.style.left = "0";
    dock.style.right = "0";
    dock.style.width = "100%";
    dock.style.top = "auto";
    dock.style.bottom = `${Math.max(0, config.bottomOffset)}px`;
    dock.style.transform = "none";
    dock.style.maxHeight = "60vh";
  }

  function updateHistoryPosition() {
    const historyPanel = state.historyPanelEl;
    if (!historyPanel) {
      return;
    }
    const rect = getPlayerRect();
    const margin = Math.max(8, config.bottomOffset);
    if (!rect) {
      historyPanel.style.left = "16px";
      historyPanel.style.top = "12%";
      historyPanel.style.height = "60vh";
      historyPanel.style.width = "min(320px, 42vw)";
      return;
    }
    const width = Math.min(320, rect.width * 0.28);
    const height = Math.max(140, rect.height - margin * 2);
    historyPanel.style.left = `${Math.max(12, rect.left + margin)}px`;
    historyPanel.style.top = `${Math.max(12, rect.top + margin)}px`;
    historyPanel.style.height = `${height}px`;
    historyPanel.style.width = `${Math.max(220, width)}px`;
  }

  function loadConfig(callback) {
    if (!chrome?.storage?.local) {
      callback();
      return;
    }
    chrome.storage.local.get({ captionsConfig: defaultConfig }, (data) => {
      const stored = data?.captionsConfig || {};
      Object.assign(config, normalizeConfig(stored));
      callback();
    });
  }

  function persistConfig() {
    if (!chrome?.storage?.local) {
      return;
    }
    chrome.storage.local.set({ captionsConfig: { ...config } });
  }

  function renderCaptionWords(overlay, captionText) {
    if (state.renderedCaptionText === captionText) {
      return;
    }
    state.renderedCaptionText = captionText;
    overlay.textContent = "";
    const lines = captionText.split("\n");
    lines.forEach((line, lineIndex) => {
      const parts = line.split(/(\s+)/);
      parts.forEach((part) => {
        if (!part) {
          return;
        }
        if (/^\s+$/.test(part)) {
          overlay.appendChild(document.createTextNode(part));
          return;
        }
        const word = createElement("span", "captions-word");
        word.textContent = part;
        overlay.appendChild(word);
      });
      if (lineIndex < lines.length - 1) {
        overlay.appendChild(document.createElement("br"));
      }
    });
  }

  function flashStatus(text) {
    state.statusOverrideText = text;
    state.statusOverrideUntil = Date.now() + STATUS_FLASH_MS;
  }

  function getCaptionText() {
    const container = document.querySelector(".ytp-caption-window-container");
    if (container) {
      return container.innerText.trim();
    }
    const segments = Array.from(
      document.querySelectorAll(".ytp-caption-segment")
    );
    if (!segments.length) {
      return "";
    }
    return segments
      .map((segment) => segment.textContent.trim())
      .filter(Boolean)
      .join(" ")
      .trim();
  }

  function getCaptionsButton() {
    return document.querySelector(".ytp-subtitles-button");
  }

  function getCaptionAvailability() {
    if (!document.querySelector("video")) {
      return "no-video";
    }
    const button = getCaptionsButton();
    if (!button || button.getAttribute("aria-disabled") === "true") {
      return "unavailable";
    }
    if (button.getAttribute("aria-pressed") === "true") {
      return "enabled";
    }
    return "disabled";
  }

  function getOverlayState() {
    const captionText = getCaptionText();
    if (captionText) {
      return {
        text: captionText,
        status: "Captions synced with YouTube. Click a word to replay.",
        variant: "active",
        isCaption: true,
        showOverlay: true,
      };
    }

    const availability = getCaptionAvailability();
    if (availability === "no-video") {
      return {
        text: "Open a YouTube video to see captions.",
        status: "No video detected.",
        variant: "idle",
        isCaption: false,
        showOverlay: true,
      };
    }
    if (availability === "unavailable") {
      return {
        text: "Captions are not available for this video.",
        status: "No captions available.",
        variant: "warning",
        isCaption: false,
        showOverlay: true,
      };
    }
    if (availability === "disabled") {
      return {
        text: "Captions are available. Turn on CC to see them.",
        status: "Captions available (off).",
        variant: "idle",
        isCaption: false,
        showOverlay: true,
      };
    }
    return {
      text: "",
      status: "Captions enabled, waiting...",
      variant: "idle",
      isCaption: false,
      showOverlay: false,
    };
  }

  function applyOverlayState(overlay, status, nextState) {
    if (!nextState.showOverlay) {
      overlay.classList.add("is-hidden");
      overlay.classList.remove("is-warning", "is-caption");
      state.renderedCaptionText = "";
      overlay.textContent = "";
      updateCaptionHistory("", false);
    } else {
      overlay.classList.remove("is-hidden");
      if (nextState.isCaption) {
        renderCaptionWords(overlay, nextState.text);
        updateCaptionHistory(nextState.text, true);
      } else {
        state.renderedCaptionText = "";
        if (overlay.textContent !== nextState.text) {
          overlay.textContent = nextState.text;
        }
        updateCaptionHistory("", false);
      }
      overlay.classList.toggle("is-warning", nextState.variant === "warning");
      overlay.classList.toggle("is-caption", nextState.isCaption);
    }
    const now = Date.now();
    const statusText =
      state.statusOverrideUntil > now
        ? state.statusOverrideText
        : nextState.status;
    if (status.textContent !== statusText) {
      status.textContent = statusText;
    }
  }

  function renderHistory() {
    const historyPanel = state.historyPanelEl;
    const historyList = state.historyListEl;
    const historyEmpty = state.historyEmptyEl;
    if (!historyPanel || !historyList || !historyEmpty) {
      return;
    }
    historyPanel.classList.toggle("is-hidden", !config.historyEnabled);
    historyList.textContent = "";
    if (!config.historyEnabled) {
      return;
    }
    if (!state.captionHistory.length) {
      historyEmpty.classList.remove("is-hidden");
      return;
    }
    historyEmpty.classList.add("is-hidden");
    state.captionHistory.forEach((entry) => {
      const item = createElement("button", "captions-history-item");
      item.type = "button";
      item.dataset.time = String(entry.time);
      const time = createElement("div", "captions-history-time");
      time.textContent = entry.timestamp;
      const text = createElement("div", "captions-history-text");
      text.textContent = entry.text;
      item.append(time, text);
      historyList.appendChild(item);
    });
    historyList.scrollTop = historyList.scrollHeight;
  }

  function recordHistoryEntry(captionText) {
    if (!config.historyEnabled || !state.historyListEl) {
      return;
    }
    const key = normalizeHistoryKey(captionText);
    if (!key || key === state.lastHistoryKey) {
      return;
    }
    state.lastHistoryKey = key;
    const video = getVideo();
    const time = video ? video.currentTime : 0;
    const entry = {
      id: (state.historyId += 1),
      text: formatHistoryText(captionText),
      time,
      timestamp: formatTimestamp(time),
    };
    state.captionHistory.push(entry);
    if (state.captionHistory.length > config.historySize) {
      state.captionHistory.shift();
    }
    renderHistory();
  }

  function shouldArchiveCaption(prevText, nextText) {
    const prevKey = normalizeHistoryKey(prevText);
    const nextKey = normalizeHistoryKey(nextText);
    if (!prevKey || prevKey === nextKey) {
      return false;
    }
    if (!nextKey) {
      return true;
    }
    return !nextKey.includes(prevKey);
  }

  function updateCaptionHistory(nextText, isCaption) {
    if (!config.historyEnabled) {
      state.lastCaptionText = isCaption ? nextText : "";
      return;
    }
    const prevText = state.lastCaptionText;
    if (isCaption) {
      if (prevText && shouldArchiveCaption(prevText, nextText)) {
        recordHistoryEntry(prevText);
      }
      state.lastCaptionText = nextText;
      return;
    }
    if (prevText) {
      recordHistoryEntry(prevText);
    }
    state.lastCaptionText = "";
  }

  function attachCaptionObserver(overlay, status) {
    const container = document.querySelector(".ytp-caption-window-container");
    if (!container && state.captionObserver) {
      state.captionObserver.disconnect();
      state.captionObserver = null;
      state.captionContainer = null;
      return;
    }
    if (container && container !== state.captionContainer) {
      if (state.captionObserver) {
        state.captionObserver.disconnect();
      }
      state.captionContainer = container;
      state.captionObserver = new MutationObserver(() => {
        applyOverlayState(overlay, status, getOverlayState());
      });
      state.captionObserver.observe(container, {
        childList: true,
        subtree: true,
        characterData: true,
      });
    }
  }

  function getPreferredLang() {
    const pageLang = document.documentElement?.lang?.trim();
    if (pageLang) {
      return pageLang;
    }
    return "en-US";
  }

  function speakWord(word, language) {
    if (!("speechSynthesis" in window)) {
      flashStatus("Speech not supported in this browser.");
      return;
    }
    if (!word) {
      return;
    }
    const utterance = new SpeechSynthesisUtterance(word);
    utterance.lang = language || getPreferredLang();
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utterance);
  }

  function setMode(newMode, buttons, overlay, status) {
    state.mode = newMode;
    buttons.forEach((button) => {
      button.classList.toggle("is-active", button.dataset.mode === newMode);
    });
    applyOverlayState(overlay, status, getOverlayState());
  }

  function togglePanel(panel, toggleButton) {
    state.panelOpen = !state.panelOpen;
    panel.style.display = state.panelOpen ? "block" : "none";
    toggleButton.setAttribute("aria-expanded", String(state.panelOpen));
  }

  function switchTab(tabName, tabs, tabButtons) {
    state.activeTab = tabName;
    tabs.forEach((tab) => {
      tab.classList.toggle("is-active", tab.dataset.tab === tabName);
    });
    tabButtons.forEach((button) => {
      button.classList.toggle("is-active", button.dataset.tab === tabName);
    });
  }

  function mount() {
    if (!document.body || document.getElementById(ROOT_ID)) {
      return;
    }

    const root = createElement("div");
    root.id = ROOT_ID;

    // DevTools Container
    const devtools = createElement("div", "captions-devtools");

    // DevTools Header
    const header = createElement("div", "captions-devtools-header");
    const headerLeft = createElement("div", "captions-devtools-header-left");
    const handle = createElement("div", "captions-devtools-handle");
    const title = createElement("div", "captions-devtools-title");
    title.textContent = "Captions DevTools";
    headerLeft.append(handle, title);

    // Tab Navigation
    const tabs = createElement("div", "captions-devtools-tabs");
    const captionsTabBtn = createElement("button", "captions-devtools-tab is-active");
    captionsTabBtn.type = "button";
    captionsTabBtn.dataset.tab = "captions";
    captionsTabBtn.textContent = "Captions";

    const historyTabBtn = createElement("button", "captions-devtools-tab");
    historyTabBtn.type = "button";
    historyTabBtn.dataset.tab = "history";
    historyTabBtn.textContent = "History";

    const dictionaryTabBtn = createElement("button", "captions-devtools-tab");
    dictionaryTabBtn.type = "button";
    dictionaryTabBtn.dataset.tab = "dictionary";
    dictionaryTabBtn.textContent = "Dictionary";

    const settingsTabBtn = createElement("button", "captions-devtools-tab");
    settingsTabBtn.type = "button";
    settingsTabBtn.dataset.tab = "settings";
    settingsTabBtn.textContent = "Settings";

    tabs.append(captionsTabBtn, historyTabBtn, dictionaryTabBtn, settingsTabBtn);

    // Header Actions
    const headerActions = createElement("div", "captions-devtools-header-actions");
    const collapseButton = createElement("button", "captions-devtools-collapse");
    collapseButton.type = "button";
    collapseButton.textContent = "âˆ’";
    collapseButton.title = "Collapse";
    headerActions.appendChild(collapseButton);

    header.append(headerLeft, tabs, headerActions);

    // DevTools Body
    const body = createElement("div", "captions-devtools-body");

    // === CAPTIONS TAB ===
    const captionsTab = createElement("div", "captions-devtools-panel is-active");
    captionsTab.dataset.tab = "captions";

    const status = createElement("div", "captions-status");
    status.textContent = "Waiting for captions...";

    const overlay = createElement("div", "captions-overlay");
    overlay.id = OVERLAY_ID;
    overlay.setAttribute("aria-live", "polite");
    overlay.textContent = "Captions will appear here.";

    const controls = createElement("div", "captions-controls");
    const backButton = createElement("button", "captions-control");
    backButton.type = "button";
    backButton.textContent = `- ${CONTROL_SEEK_SECONDS}s`;
    const playButton = createElement("button", "captions-control");
    playButton.type = "button";
    playButton.textContent = "Play";
    const forwardButton = createElement("button", "captions-control");
    forwardButton.type = "button";
    forwardButton.textContent = `+ ${CONTROL_SEEK_SECONDS}s`;
    controls.append(backButton, playButton, forwardButton);

    captionsTab.append(status, overlay, controls);

    // === HISTORY TAB ===
    const historyTab = createElement("div", "captions-devtools-panel");
    historyTab.dataset.tab = "history";

    const historyList = createElement("div", "captions-history-list");
    const historyEmpty = createElement("div", "captions-history-empty");
    historyEmpty.textContent = "Captions will appear here as you watch.";

    historyTab.append(historyList, historyEmpty);

    // === DICTIONARY TAB ===
    const dictionaryTab = createElement("div", "captions-devtools-panel");
    dictionaryTab.dataset.tab = "dictionary";

    const dictStatus = createElement("div", "captions-dict-status");
    dictStatus.textContent = "Click a word in captions to see its definition.";

    const dictWordHeader = createElement("div", "captions-dict-header");
    const dictWord = createElement("div", "captions-dict-word");
    dictWord.textContent = "";
    const dictMeta = createElement("div", "captions-dict-meta");
    dictMeta.textContent = "";
    const dictPlayBtn = createElement("button", "captions-dict-play");
    dictPlayBtn.type = "button";
    dictPlayBtn.textContent = "ðŸ”Š Play";
    dictWordHeader.append(dictWord, dictMeta, dictPlayBtn);

    const dictContent = createElement("div", "captions-dict-content");

    const defLabel = createElement("div", "captions-card-label");
    defLabel.textContent = "Definition";
    const defValue = createElement("div", "captions-card-value");
    defValue.textContent = "";

    const pronLabel = createElement("div", "captions-card-label");
    pronLabel.textContent = "Pronunciations";
    const pronValue = createElement("div", "captions-card-value");
    pronValue.textContent = "";

    const transLabel = createElement("div", "captions-card-label");
    transLabel.textContent = "Translation";
    const transValue = createElement("div", "captions-card-value");
    transValue.textContent = "";

    const formsLabel = createElement("div", "captions-card-label");
    formsLabel.textContent = "Forms";
    const formsValue = createElement("div", "captions-card-value");
    formsValue.textContent = "";

    const synonymsLabel = createElement("div", "captions-card-label");
    synonymsLabel.textContent = "Synonyms";
    const synonymsValue = createElement("div", "captions-card-value");
    synonymsValue.textContent = "";

    const antonymsLabel = createElement("div", "captions-card-label");
    antonymsLabel.textContent = "Antonyms";
    const antonymsValue = createElement("div", "captions-card-value");
    antonymsValue.textContent = "";

    const exampleLabel = createElement("div", "captions-card-label");
    exampleLabel.textContent = "Examples";
    const exampleValue = createElement("div", "captions-card-value");
    exampleValue.textContent = "";

    const sourceLabel = createElement("div", "captions-card-label");
    sourceLabel.textContent = "Sources";
    const sourceValue = createElement("div", "captions-card-value");
    sourceValue.textContent = "";

    dictContent.append(
      defLabel, defValue,
      pronLabel, pronValue,
      transLabel, transValue,
      formsLabel, formsValue,
      synonymsLabel, synonymsValue,
      antonymsLabel, antonymsValue,
      exampleLabel, exampleValue,
      sourceLabel, sourceValue
    );

    dictionaryTab.append(dictStatus, dictWordHeader, dictContent);

    // === SETTINGS TAB ===
    const settingsTab = createElement("div", "captions-devtools-panel");
    settingsTab.dataset.tab = "settings";

    const settingsScroll = createElement("div", "captions-settings-scroll");

    const langSection = createElement("div", "captions-section-title");
    langSection.textContent = "Language Settings";

    const label = createElement("label", "captions-label");
    label.textContent = "Dictionary language";
    const select = createElement("select", "captions-select");
    select.innerHTML =
      '<option value="en">English</option><option value="es">Spanish</option><option value="fr">French</option><option value="ja">Japanese</option>';

    const translationLabel = createElement("label", "captions-label");
    translationLabel.textContent = "Translation language";
    const translationSelect = createElement("select", "captions-select");
    translationSelect.innerHTML =
      '<option value="all">All</option><option value="en">English</option><option value="es">Spanish</option><option value="fr">French</option><option value="de">German</option><option value="it">Italian</option><option value="pt">Portuguese</option><option value="ja">Japanese</option><option value="ko">Korean</option>';

    const displaySection = createElement("div", "captions-section-title");
    displaySection.textContent = "Display Settings";

    const alignLabel = createElement("label", "captions-label");
    alignLabel.textContent = "Alignment";
    const alignSelect = createElement("select", "captions-select");
    alignSelect.innerHTML =
      '<option value="left">Left</option><option value="center">Center</option>';

    const sizeLabel = createElement("label", "captions-label");
    sizeLabel.textContent = "Font size";
    const sizeRow = createElement("div", "captions-range-row");
    const sizeRange = createElement("input", "captions-range");
    sizeRange.type = "range";
    sizeRange.min = "12";
    sizeRange.max = "26";
    sizeRange.step = "1";
    const sizeValue = createElement("div", "captions-range-value");
    sizeRow.append(sizeRange, sizeValue);

    const opacityLabel = createElement("label", "captions-label");
    opacityLabel.textContent = "Overlay opacity";
    const opacityRow = createElement("div", "captions-range-row");
    const opacityRange = createElement("input", "captions-range");
    opacityRange.type = "range";
    opacityRange.min = "0.55";
    opacityRange.max = "0.95";
    opacityRange.step = "0.05";
    const opacityValue = createElement("div", "captions-range-value");
    opacityRow.append(opacityRange, opacityValue);

    const positionLabel = createElement("label", "captions-label");
    positionLabel.textContent = "Sheet offset";
    const positionRow = createElement("div", "captions-range-row");
    const positionRange = createElement("input", "captions-range");
    positionRange.type = "range";
    positionRange.min = "6";
    positionRange.max = "24";
    positionRange.step = "1";
    const positionValue = createElement("div", "captions-range-value");
    positionRow.append(positionRange, positionValue);

    const widthLabel = createElement("label", "captions-label");
    widthLabel.textContent = "Sheet height";
    const widthRow = createElement("div", "captions-range-row");
    const widthRange = createElement("input", "captions-range");
    widthRange.type = "range";
    widthRange.min = "18";
    widthRange.max = "45";
    widthRange.step = "5";
    const widthValue = createElement("div", "captions-range-value");
    widthRow.append(widthRange, widthValue);

    const historySectionTitle = createElement("div", "captions-section-title");
    historySectionTitle.textContent = "History";
    const historyLabel = createElement("label", "captions-label");
    historyLabel.textContent = "History panel";
    const historyToggleRow = createElement("label", "captions-toggle-row");
    const historyToggle = createElement("input", "captions-toggle-input");
    historyToggle.type = "checkbox";
    const historyToggleText = createElement("span", "captions-toggle-text");
    historyToggleText.textContent = "Show caption history";
    historyToggleRow.append(historyToggle, historyToggleText);

    const historySizeLabel = createElement("label", "captions-label");
    historySizeLabel.textContent = "History lines";
    const historySizeRow = createElement("div", "captions-range-row");
    const historySizeRange = createElement("input", "captions-range");
    historySizeRange.type = "range";
    historySizeRange.min = "3";
    historySizeRange.max = "20";
    historySizeRange.step = "1";
    const historySizeValue = createElement("div", "captions-range-value");
    historySizeRow.append(historySizeRange, historySizeValue);

    panel.append(
      title,
      subtitle,
      modes,
      label,
      select,
      translationLabel,
      translationSelect,
      status,
      settingsTitle,
      alignLabel,
      alignSelect,
      sizeLabel,
      sizeRow,
      opacityLabel,
      opacityRow,
      positionLabel,
      positionRow,
      widthLabel,
      widthRow,
      historySectionTitle,
      historyLabel,
      historyToggleRow,
      historySizeLabel,
      historySizeRow
    );

    const overlay = createElement("div", "captions-overlay");
    overlay.id = OVERLAY_ID;
    overlay.setAttribute("aria-live", "polite");
    overlay.textContent = "Captions will appear here.";

    const controls = createElement("div", "captions-controls");
    const backButton = createElement("button", "captions-control");
    backButton.type = "button";
    backButton.textContent = `- ${CONTROL_SEEK_SECONDS}s`;
    const playButton = createElement("button", "captions-control");
    playButton.type = "button";
    playButton.textContent = "Play";
    const forwardButton = createElement("button", "captions-control");
    forwardButton.type = "button";
    forwardButton.textContent = `+ ${CONTROL_SEEK_SECONDS}s`;
    controls.append(backButton, playButton, forwardButton);

    const dock = createElement("div", "captions-dock");
    const dockHeader = createElement("div", "captions-dock-header");
    const dockTitle = createElement("div", "captions-dock-title");
    dockTitle.textContent = "Caption console";
    const dockHandle = createElement("div", "captions-dock-handle");
    const dockActions = createElement("div", "captions-dock-actions");
    const dockToggle = createElement("button", "captions-dock-toggle");
    dockToggle.type = "button";
    dockToggle.textContent = "Collapse";
    dockActions.append(controls, dockToggle);
    dockHeader.append(dockTitle, dockHandle, dockActions);
    const dockBody = createElement("div", "captions-dock-body");
    dockBody.appendChild(overlay);
    dock.append(dockHeader, dockBody);

    const card = createElement("div", "captions-card");
    card.setAttribute("aria-hidden", "true");

    const cardHeader = createElement("div", "captions-card-header");
    const cardWordWrap = createElement("div", "captions-card-word-wrap");
    const cardWord = createElement("div", "captions-card-word");
    cardWord.textContent = "Word";
    const cardMeta = createElement("div", "captions-card-meta");
    cardMeta.textContent = "Dictionary lookup";
    cardWordWrap.append(cardWord, cardMeta);
    const cardActions = createElement("div", "captions-card-actions");
    const cardPlay = createElement("button", "captions-card-action");
    cardPlay.type = "button";
    cardPlay.textContent = "Play";
    const cardClose = createElement("button", "captions-card-close");
    cardClose.type = "button";
    cardClose.textContent = "X";
    cardActions.append(cardPlay, cardClose);
    cardHeader.append(cardWordWrap, cardActions);

    const cardBody = createElement("div", "captions-card-body");
    const cardStatus = createElement("div", "captions-card-status");
    cardStatus.textContent = "Click a word to see details.";
    const defLabel = createElement("div", "captions-card-label");
    defLabel.textContent = "Definition";
    const defValue = createElement("div", "captions-card-value");
    defValue.textContent = "";
    const transLabel = createElement("div", "captions-card-label");
    transLabel.textContent = "Translation";
    const transValue = createElement("div", "captions-card-value");
    transValue.textContent = "";
    const pronLabel = createElement("div", "captions-card-label");
    pronLabel.textContent = "Pronunciations";
    const pronValue = createElement("div", "captions-card-value");
    pronValue.textContent = "";
    const formsLabel = createElement("div", "captions-card-label");
    formsLabel.textContent = "Forms";
    const formsValue = createElement("div", "captions-card-value");
    formsValue.textContent = "";
    const synonymsLabel = createElement("div", "captions-card-label");
    synonymsLabel.textContent = "Synonyms";
    const synonymsValue = createElement("div", "captions-card-value");
    synonymsValue.textContent = "";
    const antonymsLabel = createElement("div", "captions-card-label");
    antonymsLabel.textContent = "Antonyms";
    const antonymsValue = createElement("div", "captions-card-value");
    antonymsValue.textContent = "";
    const exampleLabel = createElement("div", "captions-card-label");
    exampleLabel.textContent = "Examples";
    const exampleValue = createElement("div", "captions-card-value");
    exampleValue.textContent = "";
    const sourceLabel = createElement("div", "captions-card-label");
    sourceLabel.textContent = "Sources";
    const sourceValue = createElement("div", "captions-card-value");
    cardBody.append(
      cardStatus,
      defLabel,
      defValue,
      transLabel,
      transValue,
      pronLabel,
      pronValue,
      formsLabel,
      formsValue,
      synonymsLabel,
      synonymsValue,
      antonymsLabel,
      antonymsValue,
      exampleLabel,
      exampleValue,
      sourceLabel,
      sourceValue
    );

    card.append(cardHeader, cardBody);

    const historyPanel = createElement("div", "captions-history");
    const historyPanelTitle = createElement("div", "captions-history-title");
    historyPanelTitle.textContent = "Caption history";
    const historyList = createElement("div", "captions-history-list");
    const historyEmpty = createElement("div", "captions-history-empty");
    historyEmpty.textContent = "Captions will appear here.";
    historyPanel.append(historyPanelTitle, historyList, historyEmpty);

    function setCardStatus(message) {
      if (message) {
        cardStatus.textContent = message;
        cardStatus.classList.remove("is-hidden");
      } else {
        cardStatus.textContent = "";
        cardStatus.classList.add("is-hidden");
      }
    }

    function clearCardValues() {
      defValue.textContent = "";
      transValue.textContent = "";
      pronValue.textContent = "";
      formsValue.textContent = "";
      synonymsValue.textContent = "";
      antonymsValue.textContent = "";
      exampleValue.textContent = "";
      sourceValue.textContent = "";
      cardMeta.textContent = "";
      transLabel.textContent = "Translation";
      renderSources("");
    }

    function renderSources(sourceUrl) {
      sourceValue.textContent = "";
      const apiLink = createElement("a", "captions-card-link");
      apiLink.href = "https://freedictionaryapi.com/";
      apiLink.target = "_blank";
      apiLink.rel = "noreferrer";
      apiLink.textContent = "FreeDictionaryAPI.com";
      sourceValue.appendChild(apiLink);
      if (sourceUrl) {
        sourceValue.appendChild(document.createTextNode(" | "));
        const wikiLink = createElement("a", "captions-card-link");
        wikiLink.href = sourceUrl;
        wikiLink.target = "_blank";
        wikiLink.rel = "noreferrer";
        wikiLink.textContent = "Wiktionary";
        sourceValue.appendChild(wikiLink);
      }
    }

    function renderDictionaryData(parsed) {
      const metaParts = [];
      const languageLabel = parsed.languageName || parsed.languageCode;
      if (languageLabel) {
        metaParts.push(languageLabel);
      }
      if (parsed.partOfSpeech) {
        metaParts.push(parsed.partOfSpeech);
      }
      cardMeta.textContent = metaParts.join(" | ");

      if (parsed.translationLang && parsed.translationLang !== "all") {
        transLabel.textContent = `Translation (${parsed.translationLang.toUpperCase()})`;
      } else {
        transLabel.textContent = "Translation";
      }

      defValue.textContent = parsed.definitions.length
        ? formatLines(parsed.definitions, (definition, index) => {
            return `${index + 1}. ${definition}`;
          })
        : "No definition found.";

      pronValue.textContent = parsed.pronunciations.length
        ? formatLines(parsed.pronunciations.slice(0, 4), (item) => `- ${item}`)
        : "No pronunciations listed.";

      formsValue.textContent = parsed.forms.length
        ? formatLines(parsed.forms.slice(0, 6), (item) => `- ${item}`)
        : "No forms provided.";

      synonymsValue.textContent = parsed.synonyms.length
        ? parsed.synonyms.slice(0, 8).join(", ")
        : "No synonyms provided.";

      antonymsValue.textContent = parsed.antonyms.length
        ? parsed.antonyms.slice(0, 8).join(", ")
        : "No antonyms provided.";

      transValue.textContent = parsed.translations.length
        ? formatLines(parsed.translations.slice(0, 4), (item) => {
            const words = item.words.slice(0, 4).join(", ");
            return `${item.name} (${item.code}): ${words}`;
          })
        : parsed.translationLang && parsed.translationLang !== "all"
          ? `No translations for ${parsed.translationLang.toUpperCase()}.`
          : "No translations returned.";

      exampleValue.textContent = parsed.examples.length
        ? formatLines(parsed.examples, (example) => `- ${example}`)
        : "No examples provided.";

      renderSources(parsed.sourceUrl);
    }

    async function lookupWord(wordText) {
      if (!wordText) {
        return;
      }
      const language = select.value || config.dictionaryLang || "en";
      const translationLang =
        translationSelect.value || config.translationLang || "all";
      const cacheKey = getCacheKey(wordText, language);
      const cached = getCachedEntry(cacheKey);
      if (cached) {
        renderDictionaryData(parseDictionaryData(cached, translationLang));
        setCardStatus("");
        return;
      }

      const requestId = ++state.lookupRequestId;
      setCardStatus("Loading dictionary...");
      try {
        const data = await fetchDictionaryEntry(wordText, language);
        if (requestId !== state.lookupRequestId) {
          return;
        }
        setCachedEntry(cacheKey, data);
        renderDictionaryData(parseDictionaryData(data, translationLang));
        setCardStatus("");
      } catch (error) {
        if (requestId !== state.lookupRequestId) {
          return;
        }
        clearCardValues();
        setCardStatus("Dictionary lookup failed.");
      }
    }

    root.append(toggleButton, panel, dock, historyPanel);
    root.appendChild(card);
    document.body.appendChild(root);

    state.historyPanelEl = historyPanel;
    state.historyListEl = historyList;
    state.historyEmptyEl = historyEmpty;
    state.dockEl = dock;

    const modeButtons = [sameButton, translateButton];
    modeButtons.forEach((button) => {
      button.addEventListener("click", () => {
        setMode(button.dataset.mode, modeButtons, overlay, status);
      });
    });

    toggleButton.addEventListener("click", () => {
      togglePanel(panel, toggleButton);
    });

    dockToggle.addEventListener("click", () => {
      dock.classList.toggle("is-collapsed");
      dockToggle.textContent = dock.classList.contains("is-collapsed")
        ? "Expand"
        : "Collapse";
      updateDockPosition();
    });

    document.addEventListener("keydown", (event) => {
      if (event.altKey && event.key.toLowerCase() === "c") {
        const activeTag = document.activeElement?.tagName;
        if (activeTag === "INPUT" || activeTag === "TEXTAREA") {
          return;
        }
        togglePanel(panel, toggleButton);
      }
    });

    overlay.addEventListener("click", (event) => {
      if (!(event.target instanceof Element)) {
        return;
      }
      const word = event.target.closest(".captions-word");
      if (!word) {
        return;
      }
      const video = document.querySelector("video");
      if (!video) {
        flashStatus("No video to replay.");
        return;
      }
      const nextTime = Math.max(0, video.currentTime - REPLAY_BACK_SECONDS);
      video.currentTime = nextTime;
      const wordText = normalizeWord(word.textContent);
      if (!wordText) {
        flashStatus("Select a word to replay.");
        return;
      }
      flashStatus(`Replaying: ${wordText}`);
      state.activeWord = wordText;
      clearCardValues();
      cardWord.textContent = wordText;
      cardMeta.textContent = "Loading...";
      setCardStatus("Loading dictionary...");
      lookupWord(wordText);
      card.classList.add("is-open");
      card.setAttribute("aria-hidden", "false");
      video.pause();
      updateControls();
      applyOverlayState(overlay, status, getOverlayState());
    });

    historyList.addEventListener("click", (event) => {
      if (!(event.target instanceof Element)) {
        return;
      }
      const item = event.target.closest(".captions-history-item");
      if (!item) {
        return;
      }
      const time = Number(item.dataset.time);
      if (!Number.isFinite(time)) {
        return;
      }
      const video = getVideo();
      if (!video) {
        flashStatus("No video to seek.");
        return;
      }
      video.currentTime = Math.max(0, time - 0.2);
      const playPromise = video.play();
      if (playPromise && typeof playPromise.catch === "function") {
        playPromise.catch(() => {});
      }
      flashStatus(`Jumped to ${formatTimestamp(time)}`);
    });

    function updateControls() {
      const video = getVideo();
      const isReady = Boolean(video);
      controls.classList.toggle("is-disabled", !isReady);
      backButton.disabled = !isReady;
      playButton.disabled = !isReady;
      forwardButton.disabled = !isReady;
      if (!video) {
        playButton.textContent = "Play";
        return;
      }
      playButton.textContent = video.paused ? "Play" : "Pause";
    }

    backButton.addEventListener("click", () => {
      const video = getVideo();
      if (!video) {
        flashStatus("No video to seek.");
        return;
      }
      video.currentTime = Math.max(0, video.currentTime - CONTROL_SEEK_SECONDS);
      updateControls();
    });

    playButton.addEventListener("click", () => {
      const video = getVideo();
      if (!video) {
        flashStatus("No video to control.");
        return;
      }
      if (video.paused) {
        const playPromise = video.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch(() => {});
        }
      } else {
        video.pause();
      }
      updateControls();
    });

    forwardButton.addEventListener("click", () => {
      const video = getVideo();
      if (!video) {
        flashStatus("No video to seek.");
        return;
      }
      video.currentTime = Math.min(
        video.duration || Infinity,
        video.currentTime + CONTROL_SEEK_SECONDS
      );
      updateControls();
    });

    cardPlay.addEventListener("click", () => {
      speakWord(state.activeWord, select.value);
    });

    cardClose.addEventListener("click", () => {
      card.classList.remove("is-open");
      card.setAttribute("aria-hidden", "true");
    });

    function syncControls() {
      alignSelect.value = config.align;
      sizeRange.value = String(config.fontSize);
      sizeValue.textContent = `${config.fontSize}px`;
      opacityRange.value = String(config.opacity.toFixed(2));
      opacityValue.textContent = `${Math.round(config.opacity * 100)}%`;
      positionRange.value = String(config.bottomOffset);
      positionValue.textContent = `${config.bottomOffset}px`;
      widthRange.value = String(config.maxWidth);
      widthValue.textContent = `${config.maxWidth}vh`;
      select.value = config.dictionaryLang;
      translationSelect.value = config.translationLang;
      historyToggle.checked = config.historyEnabled;
    historySizeRange.value = String(config.historySize);
    historySizeValue.textContent = `${config.historySize}`;
    }

    alignSelect.addEventListener("change", () => {
      config.align = alignSelect.value;
      applyConfig(root, overlay);
      persistConfig();
    });

    select.addEventListener("change", () => {
      config.dictionaryLang = select.value;
      persistConfig();
      if (state.activeWord && card.classList.contains("is-open")) {
        lookupWord(state.activeWord);
      }
    });

    translationSelect.addEventListener("change", () => {
      config.translationLang = translationSelect.value;
      persistConfig();
      if (state.activeWord && card.classList.contains("is-open")) {
        lookupWord(state.activeWord);
      }
    });

    historyToggle.addEventListener("change", () => {
      config.historyEnabled = historyToggle.checked;
      persistConfig();
      renderHistory();
    });

    historySizeRange.addEventListener("input", () => {
      config.historySize = Number(historySizeRange.value);
      if (state.captionHistory.length > config.historySize) {
        while (state.captionHistory.length > config.historySize) {
          state.captionHistory.shift();
        }
      }
      syncControls();
      persistConfig();
      renderHistory();
    });

    sizeRange.addEventListener("input", () => {
      config.fontSize = Number(sizeRange.value);
      applyConfig(root, overlay);
      syncControls();
      persistConfig();
    });

    opacityRange.addEventListener("input", () => {
      config.opacity = Number(opacityRange.value);
      applyConfig(root, overlay);
      syncControls();
      persistConfig();
    });

    positionRange.addEventListener("input", () => {
      config.bottomOffset = Number(positionRange.value);
      applyConfig(root, overlay);
      syncControls();
      persistConfig();
      updateDockPosition();
    });

    widthRange.addEventListener("input", () => {
      config.maxWidth = Number(widthRange.value);
      applyConfig(root, overlay);
      syncControls();
      persistConfig();
      updateDockPosition();
    });

    loadConfig(() => {
      applyConfig(root, overlay);
      syncControls();
      attachCaptionObserver(overlay, status);
      applyOverlayState(overlay, status, getOverlayState());
      renderHistory();
      updateDockPosition();
      updateHistoryPosition();
      updateControls();
    });

    setInterval(() => {
      attachCaptionObserver(overlay, status);
      applyOverlayState(overlay, status, getOverlayState());
      updateDockPosition();
      updateHistoryPosition();
      updateControls();
    }, CAPTION_POLL_MS);

    window.addEventListener("resize", () => {
      updateDockPosition();
      updateHistoryPosition();
    });
    window.addEventListener(
      "scroll",
      () => {
        updateDockPosition();
        updateHistoryPosition();
      },
      true
    );
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", mount, { once: true });
  } else {
    mount();
  }
})();
